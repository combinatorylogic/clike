%literate:

\section{ASTs definitions}

\subsection{The source language (generated by a parser)}

\fbox{\includegraphics[scale=0.4]{clike.pdf}}

\pfcode{
ast clike {
   lltoplev =
       cfunc(pos:LOC, llcallconv:cc, lltype:ret, topident:name, bool:va, 
              *llfuncarg:args, llcode:body)
     | efunc(pos:LOC, llcallconv:cc, lltype:ret, topident:name, bool:va,
              *llfuncarg:args)
     | typedef(pos:LOC, lltype:tp, topident:name)
     | global(pos:LOC, lltype:tp, llvarname:name)
     | eglobal(pos:LOC, lltype:tp, llvarname:name)
     | begin(.*lltoplev:es)

     // Should not appear after macro expansions
     | macroapp(ident:nm, .*llmacroarg:args)

     // For storing intermediate LLVM code:
     | xfunc(lltype:ret, topident:name, bool:va, . *llfuncarg:args)
     | xglobal(lltype:tp, topident:name)
     // Bypass entries
     | xxexpr(llexpr:e)
     | xxcode(llcode:c)
     ;

   topident is ident:v; // a dummy node

   llmacroarg =
       stmt(llcode:s)
     | top(lltoplev:t)
     | type(lltype:t)
     | verb(any:v)
     ;

   lltmacroarg =
       stmt(llcode:s)
     | expr(llexpr:s)
     | lvalue(lvalue:s)
     | var(ident:v)
     | type(lltype:t)
     | verb(any:v)
     ;

   llvarname = v(ident:name)
             // Should not be present after macro expansion:
             | p(lltypepatch:p)
             ;

   llfuncarg is (lltype:tp, llvarname:name);
  
   llcode =
       begin(. *llcode:es)
     | label(pos:LOC, ident:lbl)
     | vardef(lltype:tp, llvarname:name)
     | set(pos:LOC, lvalue:l, llexpr:e)
     | expr(llexpr:e)
     | return(pos:LOC,llexpr:e)
     | vreturn(pos:LOC)
     | goto(pos:LOC, ident:lbl)
     | for(pos:LOC, *llcode:init, llexpr:cnd, llcode:step, llcode:body)
     | while(pos:LOC, llexpr:cnd, llcode:body)
     | do(pos:LOC, llcode:body, llexpr:cnd)
     | switch(pos:LOC, llexpr:e, *llswitchopt:opts, *llcode:dflt)
     | if3(pos:LOC, llexpr:e, llcode:tr, llcode:fl)
     | if2(pos:LOC, llexpr:e, llcode:tr)
     | break(pos:LOC)
     | nop()

     // Valid till the type propagation pass only
     | varinit(ident:l, llexpr:r)

     // Top level things lifting, should be eliminated right after typing 
     //    pass (as it may be a result of a macro application)
     | toplift(any:t) 

     // A temporary node for clike2 translation only, should never be generated
     | passexpr(llexpr:e)
     | passlvalue(lvalue:e)

     // Should not appear after macro expansions
     | macroapp(ident:nm, .*llmacroarg:args)
     | manyvardefs(lltype:tp, .*llvardefpair:vars)
     | protofor(pos:LOC, *llcode:init, *llexpr:cnds, *llexpr:steps, llcode:body)
     ;

   llvardefpair = s(llvarname:nm)
                | d(llvarname:nm, llexpr:ini)
                ;

   llswitchopt is (llconst: value, llcode:action);
       
   llexpr =
       inblock(pos:LOC, llcode:c, llexpr:r)
     | call(pos:LOC, ident:id, .*llexpr:args)
     | callptr(pos:LOC, lvalue:fn, .*llexpr:args)
     | stdcallpfx(llexpr:e)
     | bin(pos:LOC, ident:op, llexpr:l, llexpr:r)
     
     | compop(pos:LOC, ident:op, llexpr:l, llexpr:r)
     | tri(llexpr:cnd, llexpr:tr, llexpr:fl)

     | un(ident:op, llexpr:e)
     | typecast(lltype:t, llexpr:e)
     | pre(ident:op, lvalue:v, .*lltype:vtyp)
     | post(ident:op, lvalue:v, .*lltype:vtyp)

     | modop(pos:LOC, ident:op, lvalue:l, llexpr:r)

     | eset(pos:LOC, lvalue:v, llexpr:e)
     | const(llconst:c)
     | globstring(string:s)

     | logand(pos:LOC, .*llexpr:es)
     | logor(pos:LOC, .*llexpr:es)

     | var(ident:nm)
     | arg(ident:nm)
     | glob(ident:nm)
     | globfun(ident:nm)

     | array(lvalue:ar, .*llexpr:idxs)
     | ref(lvalue:e)
     | deref(llexpr:e)
     | getelt(lvalue:e, ident:fldnm)
     | sizeof(lltype:t)

     // Special dual-stage macro expansion (propagation + post-propagation)
     | typedmacro(ident:nm, .*lltmacroarg:args)

     // Should not appear after macro expansions
     | macroapp(ident:nm, .*llmacroarg:args)
     | protoinblock(pos:LOC, .*llcode:c)
     | commaexprs(pos:LOC, .*llexpr:es)
     ;

   lvalue =
       var(ident:nm)
     | glob(ident:nm)
     | globfun(ident:nm)
     | arg(ident:nm)
     | array(lvalue:ar, .*llexpr:idxs)
     | deref(llexpr:e)
     | getelt(lvalue:e, ident:fldnm)
     ;

   llconst =
       null()
     | integer(ident:itype, int:v)
     | real(ident:rtype, real:v)
     | string(string:s)
     | constarray(. *llconst:elts)
     | conststruct(lltype:t, .*llcstrelt:elts)
     | zero(lltype:t)
     ;
   
   llcstrelt is (ident:fld, llconst:v);
   llstrelt is (ident:fld, lltype:t);
   llmacrostrelt is (lltype:t, llvarname:fld);

   lltypepatch =
     | ptr(lltypepatch:t)
     | fun(lltypepatch:ret, bool:va, .*lltype:args)
     | array(lltypepatch:t, .*int:dims)
     | v(ident:nm)
     ;

   lltype =
       integer(ident:itype)
     | real(ident:rtype)
     | alias(ident:x)
     | struct(*ident:nm, .*llstrelt:ts)
     | structalias(ident:nm)
     | structref(ident:nm)
     | ptr(lltype:t)
     | fun(lltype:ret, bool:va, .*lltype:args)
     | array(lltype:t, .*int:dims)
     | string()
     | void()

     // Qualified type
     | qual(qualifiers:c, lltype:t)
     | attr(attribute:a, lltype:t) // source level, to be translated to qual

     // Invalid after macro expansion
     | macrostruct(*ident:nm, .*llmacrostrelt:ts)

     // Intermediate, used for transforms
     | null()
     | bool()
     | arg(lltype:t)
     | nop()
     ;
}
}

\phcode{%draw:ast:graph(clike,"./doc/clike.dot")}


\subsection{Same language with all the expressions annotated with their types}

\pfcode{
ast clike2 : clike ( llexpr -> lloexpr, lvalue -> olvalue,
                     llvarname -> ollvarname ) {
   llexpr is (lltype:t , . lloexpr:e);
   lvalue is (lltype:t , . olvalue:e);
}
}


\subsection{A first intermediate language}

This intermediate language is already mostly LLVM, but expressions 
are allowed to be nested and types annotations are still present.

\pfcode{
ast clike3 {
  llstmt2 =
       set(ident:nm, llexpr2:e)
     | setstring(ident:nm, string:s)
     | ret(llexpr2:value)
     | vret()
     | br(llexpr2:cnd, irlabel:tr, irlabel:fl)
     | br_label(ident:nm)
     | switch(llexpr2:value, irlabel:els, *irswitchdst:cases)
     | store(llexpr1:ptr, llexpr2:e)
     | storevar(ident:ptr, llexpr2:e)
     | label(ident:nm)
     | begin(.*llstmt2:es)
     | nop()
     // An intermediate instruction, must be removed before compilation
     | break()
     ;

  irswitchdst is ( llval:value, irlabel:dst );

  llexpr2 is (lltype:t,.llexpr1:e);

  llexpr1 =
     binary(irbinop:op, llexpr2:l, llexpr2:r)
   | extractelement(int:n, llexpr2:v, llexpr2:idx)
   | insertelement(int:n, irtype:t, llexpr2:v, llexpr2:elt, llexpr2:idx)
   | shufflevector(int:n1, llexpr2:val1, int:n1, llexpr2:val2, llexpr2:mask)
   | extractvalue(iraggtype:t, llexpr2:v, llexpr2:idx)
   | insertvalue(llexpr2:v, irtype:tv, llexpr2:elt, llexpr2:idx)
   | alloca(irtype:t)
   | load(llexpr2:ptr)
   | loadvar(ident:id) // shortcut
   | getelementptr(llexpr2:ptr, . *llexpr2:idxs)
   | getelementptr_inbounds(llexpr2:ptr, . *llexpr2:idxs)
   | convop(irconvop:op, llexpr2:v, irtype:t)
   | icmp(iricond:vcond, llexpr2:lhs, llexpr2:rhs)
   | fcmp(irfcond:vcond, llexpr2:lhs, llexpr2:rhs)
   | phi(irtype:t, .*irphi:dsts)
   | select(llexpr2:vif, llexpr2:vthen, llexpr2:velse)
   | call(ident:fn, .*llexpr2:args)
   | callptr(llexpr2:fn, .*llexpr2:args)
   | callptrstd(llexpr2:fn, .*llexpr2:args)
   | ptr(llexpr2:src, irtype:dst)
   | liftstatements(llstmt2:s, llexpr2:e)
   | val(llval:v)
   | stringtmp(string:s)
   ;
 
  llval =
          false()
        | true()
        | null(irtype:t)
        | integer(int:v, .*ident:itp)
        | float(float:v, .*ident:ftp)
        | struct(ident:nm, . *irstructel:elts)
        | array(irtype:t, . *llval:elts)
        | vector(. *llval:elts)
        | zero(irtype:t)
        | undef(irtype:t)
        | string(string:s)
        | blockaddress(irfunction:fn, irblock:blk)
        | var(ident:nm)
        | global(ident:nm)
        | globalfun(ident:nm)
        | sizeof(irtype:t)
        ;
}
}


